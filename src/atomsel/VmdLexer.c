/** \file
 *  This C source file was generated by $ANTLR version 3.1.3 Mar 18, 2009 10:09:25
 *
 *     -  From the grammar source file : Vmd.g
 *     -                            On : 2011-10-25 16:08:47
 *     -                 for the lexer : VmdLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "VmdLexer.h"
/* ----------------------------------------- */


/** String literals used by VmdLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E, 0x62, 0x6F, 0x6E, 0x64, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x65, 0x78, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x70, 0x62, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x73, 0x61, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x61, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x74, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x2A, 0x2A,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pVmdLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pVmdLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pVmdLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mAND    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mOR    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mLESS    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mLESSEQ    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mMORE    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mMOREEQ    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mEQUAL    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mNEQUAL    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mWITHIN    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mWITHINBONDS    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mEXWITHIN    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mPBWITHIN    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mOF    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mSAME    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mAS    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mNOT    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mTO    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__32    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__33    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__34    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__35    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__36    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__37    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__38    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__39    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mT__40    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mLIT    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mALPHA    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mDIGIT    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mWS    (pVmdLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pVmdLexer ctx);
static void	VmdLexerFree(pVmdLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
VmdLexerFree  (pVmdLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Vmd.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called VmdLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pVmdLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pVmdLexer VmdLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return VmdLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called VmdLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pVmdLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pVmdLexer VmdLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pVmdLexer ctx; // Context structure we will build and return

    ctx = (pVmdLexer) ANTLR3_CALLOC(1, sizeof(VmdLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in VmdLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our VmdLexer interface
     */
    ctx->mAND	= mAND;
    ctx->mOR	= mOR;
    ctx->mLESS	= mLESS;
    ctx->mLESSEQ	= mLESSEQ;
    ctx->mMORE	= mMORE;
    ctx->mMOREEQ	= mMOREEQ;
    ctx->mEQUAL	= mEQUAL;
    ctx->mNEQUAL	= mNEQUAL;
    ctx->mWITHIN	= mWITHIN;
    ctx->mWITHINBONDS	= mWITHINBONDS;
    ctx->mEXWITHIN	= mEXWITHIN;
    ctx->mPBWITHIN	= mPBWITHIN;
    ctx->mOF	= mOF;
    ctx->mSAME	= mSAME;
    ctx->mAS	= mAS;
    ctx->mNOT	= mNOT;
    ctx->mTO	= mTO;
    ctx->mT__32	= mT__32;
    ctx->mT__33	= mT__33;
    ctx->mT__34	= mT__34;
    ctx->mT__35	= mT__35;
    ctx->mT__36	= mT__36;
    ctx->mT__37	= mT__37;
    ctx->mT__38	= mT__38;
    ctx->mT__39	= mT__39;
    ctx->mT__40	= mT__40;
    ctx->mLIT	= mLIT;
    ctx->mALPHA	= mALPHA;
    ctx->mDIGIT	= mDIGIT;
    ctx->mWS	= mWS;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= VmdLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( AND | OR | LESS | LESSEQ | MORE | MOREEQ | EQUAL | NEQUAL | WITHIN | WITHINBONDS | EXWITHIN | PBWITHIN | OF | SAME | AS | NOT | TO | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | LIT | WS );
 */
static const ANTLR3_INT32 dfa2_eot[76] =
    {
	-1, 21, 21, 28, 30, -1, -1, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, -1, 
	38, -1, -1, -1, -1, 21, 40, 41, 42, -1, -1, -1, -1, 21, 21, 21, 21, 21, 
	48, 49, -1, 50, -1, -1, -1, 21, 21, 21, 21, 55, -1, -1, -1, 21, 21, 21, 
	59, -1, 21, 21, 21, -1, 64, 21, 21, 21, -1, 21, 21, 21, 71, 72, 21, -1, 
	-1, 21, 75, -1
    };
static const ANTLR3_INT32 dfa2_eof[76] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_min[76] =
    {
	10, 110, 102, 61, 61, -1, -1, 105, 120, 98, 97, 111, 111, -1, -1, -1, -1, 
	-1, 39, -1, -1, -1, -1, 100, 39, 39, 39, -1, -1, -1, -1, 116, 119, 119, 
	109, 116, 39, 39, -1, 39, -1, -1, -1, 104, 105, 105, 101, 39, -1, -1, -1, 
	105, 116, 116, 39, -1, 110, 104, 104, -1, 39, 105, 105, 111, -1, 110, 110, 
	110, 39, 39, 100, -1, -1, 115, 39, -1
    };
static const ANTLR3_INT32 dfa2_max[76] =
    {
	122, 115, 114, 61, 61, -1, -1, 105, 120, 98, 97, 111, 111, -1, -1, -1, 
	-1, -1, 122, -1, -1, -1, -1, 100, 122, 122, 122, -1, -1, -1, -1, 116, 119, 
	119, 109, 116, 122, 122, -1, 122, -1, -1, -1, 104, 105, 105, 101, 122, 
	-1, -1, -1, 105, 116, 116, 122, -1, 110, 104, 104, -1, 122, 105, 105, 111, 
	-1, 110, 110, 110, 122, 122, 100, -1, -1, 115, 122, -1
    };
static const ANTLR3_INT32 dfa2_accept[76] =
    {
	-1, -1, -1, -1, -1, 7, 8, -1, -1, -1, -1, -1, -1, 18, 19, 20, 21, 22, -1, 
	24, 26, 27, 28, -1, -1, -1, -1, 4, 3, 6, 5, -1, -1, -1, -1, -1, -1, -1, 
	23, -1, 15, 2, 13, -1, -1, -1, -1, -1, 17, 25, 1, -1, -1, -1, -1, 16, -1, 
	-1, -1, 14, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 11, 12, -1, -1, 
	10
    };
static const ANTLR3_INT32 dfa2_special[76] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa2_T_empty	    NULL

static const ANTLR3_INT32 dfa2_T0[] =
    {
	36
    };static const ANTLR3_INT32 dfa2_T1[] =
    {
	21, -1, -1, 21, -1, -1, -1, 21, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, -1, -1, -1, -1, -1, -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, 
	-1, -1, 21, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21
    };static const ANTLR3_INT32 dfa2_T2[] =
    {
	27
    };static const ANTLR3_INT32 dfa2_T3[] =
    {
	39
    };static const ANTLR3_INT32 dfa2_T4[] =
    {
	22, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 22, 6, 15, -1, -1, -1, -1, 21, 13, 14, 18, 16, -1, 17, 
	21, 19, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, 3, 5, 4, -1, -1, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 20, 21, -1, 1, 21, 21, 21, 
	8, 21, 21, 21, 21, 21, 21, 21, 21, 11, 2, 9, 21, 21, 10, 12, 21, 21, 7, 
	21, 21, 21
    };static const ANTLR3_INT32 dfa2_T5[] =
    {
	53
    };static const ANTLR3_INT32 dfa2_T6[] =
    {
	45
    };static const ANTLR3_INT32 dfa2_T7[] =
    {
	62
    };static const ANTLR3_INT32 dfa2_T8[] =
    {
	58
    };static const ANTLR3_INT32 dfa2_T9[] =
    {
	69
    };static const ANTLR3_INT32 dfa2_T10[] =
    {
	66
    };static const ANTLR3_INT32 dfa2_T11[] =
    {
	34
    };static const ANTLR3_INT32 dfa2_T12[] =
    {
	46
    };static const ANTLR3_INT32 dfa2_T13[] =
    {
	54
    };static const ANTLR3_INT32 dfa2_T14[] =
    {
	21, -1, -1, 37, -1, -1, -1, 21, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, -1, -1, -1, -1, -1, -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, 
	-1, -1, 21, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21
    };static const ANTLR3_INT32 dfa2_T15[] =
    {
	35
    };static const ANTLR3_INT32 dfa2_T16[] =
    {
	47
    };static const ANTLR3_INT32 dfa2_T17[] =
    {
	74
    };static const ANTLR3_INT32 dfa2_T18[] =
    {
	73
    };static const ANTLR3_INT32 dfa2_T19[] =
    {
	70
    };static const ANTLR3_INT32 dfa2_T20[] =
    {
	67
    };static const ANTLR3_INT32 dfa2_T21[] =
    {
	52
    };static const ANTLR3_INT32 dfa2_T22[] =
    {
	57
    };static const ANTLR3_INT32 dfa2_T23[] =
    {
	32
    };static const ANTLR3_INT32 dfa2_T24[] =
    {
	44
    };static const ANTLR3_INT32 dfa2_T25[] =
    {
	33
    };static const ANTLR3_INT32 dfa2_T26[] =
    {
	68
    };static const ANTLR3_INT32 dfa2_T27[] =
    {
	61
    };static const ANTLR3_INT32 dfa2_T28[] =
    {
	65
    };static const ANTLR3_INT32 dfa2_T29[] =
    {
	21, -1, -1, 21, -1, -1, -1, 21, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, -1, -1, -1, -1, -1, -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, 
	-1, -1, 21, -1, 21, 63, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21
    };static const ANTLR3_INT32 dfa2_T30[] =
    {
	23, -1, -1, -1, -1, 24
    };static const ANTLR3_INT32 dfa2_T31[] =
    {
	60
    };static const ANTLR3_INT32 dfa2_T32[] =
    {
	56
    };static const ANTLR3_INT32 dfa2_T33[] =
    {
	51
    };static const ANTLR3_INT32 dfa2_T34[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25
    };static const ANTLR3_INT32 dfa2_T35[] =
    {
	43
    };static const ANTLR3_INT32 dfa2_T36[] =
    {
	29
    };static const ANTLR3_INT32 dfa2_T37[] =
    {
	31
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa2_transitions[] =
{
    dfa2_T4, dfa2_T30, dfa2_T34, dfa2_T2, dfa2_T36, dfa2_T_empty, dfa2_T_empty, 
    dfa2_T37, dfa2_T23, dfa2_T25, dfa2_T11, dfa2_T15, dfa2_T0, dfa2_T_empty, 
    dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T14, dfa2_T_empty, 
    dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T3, dfa2_T1, dfa2_T1, 
    dfa2_T1, dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T35, 
    dfa2_T24, dfa2_T6, dfa2_T12, dfa2_T16, dfa2_T1, dfa2_T1, dfa2_T_empty, 
    dfa2_T1, dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, dfa2_T33, dfa2_T21, 
    dfa2_T5, dfa2_T13, dfa2_T1, dfa2_T_empty, dfa2_T_empty, dfa2_T_empty, 
    dfa2_T32, dfa2_T22, dfa2_T8, dfa2_T1, dfa2_T_empty, dfa2_T31, dfa2_T27, 
    dfa2_T7, dfa2_T_empty, dfa2_T29, dfa2_T28, dfa2_T10, dfa2_T20, dfa2_T_empty, 
    dfa2_T26, dfa2_T9, dfa2_T19, dfa2_T1, dfa2_T1, dfa2_T18, dfa2_T_empty, 
    dfa2_T_empty, dfa2_T17, dfa2_T1, dfa2_T_empty	
};


/* Declare tracking structure for Cyclic DFA 2
 */
static
ANTLR3_CYCLIC_DFA cdfa2
    =	{
	    2,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( AND | OR | LESS | LESSEQ | MORE | MOREEQ | EQUAL | NEQUAL | WITHIN | WITHINBONDS | EXWITHIN | PBWITHIN | OF | SAME | AS | NOT | TO | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | LIT | WS );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa2_eot,	    /* EOT table			    */
	    dfa2_eof,	    /* EOF table			    */
	    dfa2_min,	    /* Minimum tokens for each state    */
	    dfa2_max,	    /* Maximum tokens for each state    */
	    dfa2_accept,	/* Accept table			    */
	    dfa2_special,	/* Special transition states	    */
	    dfa2_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 2
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:5: ( 'and' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the characters the constitute the token AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND;
       
    
    // Vmd.g:7:5: ( 'and' )
    // Vmd.g:7:7: 'and'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;

}
// $ANTLR end AND

//   Comes from: 8:4: ( 'or' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR
 *
 * Looks to match the characters the constitute the token OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOR(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OR;
       
    
    // Vmd.g:8:4: ( 'or' )
    // Vmd.g:8:6: 'or'
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleOREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOREx; /* Prevent compiler warnings */
    ruleOREx: ;

}
// $ANTLR end OR

//   Comes from: 9:6: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS
 *
 * Looks to match the characters the constitute the token LESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LESS;
       
    
    // Vmd.g:9:6: ( '<' )
    // Vmd.g:9:8: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleLESSEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLESSEx; /* Prevent compiler warnings */
    ruleLESSEx: ;

}
// $ANTLR end LESS

//   Comes from: 10:8: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESSEQ
 *
 * Looks to match the characters the constitute the token LESSEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESSEQ(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LESSEQ;
       
    
    // Vmd.g:10:8: ( '<=' )
    // Vmd.g:10:10: '<='
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleLESSEQEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLESSEQEx; /* Prevent compiler warnings */
    ruleLESSEQEx: ;

}
// $ANTLR end LESSEQ

//   Comes from: 11:6: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MORE
 *
 * Looks to match the characters the constitute the token MORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMORE(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MORE;
       
    
    // Vmd.g:11:6: ( '>' )
    // Vmd.g:11:8: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleMOREEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMOREEx; /* Prevent compiler warnings */
    ruleMOREEx: ;

}
// $ANTLR end MORE

//   Comes from: 12:8: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MOREEQ
 *
 * Looks to match the characters the constitute the token MOREEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMOREEQ(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MOREEQ;
       
    
    // Vmd.g:12:8: ( '>=' )
    // Vmd.g:12:10: '>='
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleMOREEQEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMOREEQEx; /* Prevent compiler warnings */
    ruleMOREEQEx: ;

}
// $ANTLR end MOREEQ

//   Comes from: 13:7: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUAL
 *
 * Looks to match the characters the constitute the token EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUAL(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUAL;
       
    
    // Vmd.g:13:7: ( '==' )
    // Vmd.g:13:9: '=='
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleEQUALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEQUALEx; /* Prevent compiler warnings */
    ruleEQUALEx: ;

}
// $ANTLR end EQUAL

//   Comes from: 14:8: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEQUAL
 *
 * Looks to match the characters the constitute the token NEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEQUAL(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NEQUAL;
       
    
    // Vmd.g:14:8: ( '!=' )
    // Vmd.g:14:10: '!='
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleNEQUALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNEQUALEx; /* Prevent compiler warnings */
    ruleNEQUALEx: ;

}
// $ANTLR end NEQUAL

//   Comes from: 15:8: ( 'within' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WITHIN
 *
 * Looks to match the characters the constitute the token WITHIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWITHIN(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WITHIN;
       
    
    // Vmd.g:15:8: ( 'within' )
    // Vmd.g:15:10: 'within'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleWITHINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWITHINEx; /* Prevent compiler warnings */
    ruleWITHINEx: ;

}
// $ANTLR end WITHIN

//   Comes from: 16:13: ( 'withinbonds' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WITHINBONDS
 *
 * Looks to match the characters the constitute the token WITHINBONDS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWITHINBONDS(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WITHINBONDS;
       
    
    // Vmd.g:16:13: ( 'withinbonds' )
    // Vmd.g:16:15: 'withinbonds'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleWITHINBONDSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWITHINBONDSEx; /* Prevent compiler warnings */
    ruleWITHINBONDSEx: ;

}
// $ANTLR end WITHINBONDS

//   Comes from: 17:10: ( 'exwithin' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXWITHIN
 *
 * Looks to match the characters the constitute the token EXWITHIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXWITHIN(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXWITHIN;
       
    
    // Vmd.g:17:10: ( 'exwithin' )
    // Vmd.g:17:12: 'exwithin'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleEXWITHINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXWITHINEx; /* Prevent compiler warnings */
    ruleEXWITHINEx: ;

}
// $ANTLR end EXWITHIN

//   Comes from: 18:10: ( 'pbwithin' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PBWITHIN
 *
 * Looks to match the characters the constitute the token PBWITHIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPBWITHIN(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PBWITHIN;
       
    
    // Vmd.g:18:10: ( 'pbwithin' )
    // Vmd.g:18:12: 'pbwithin'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto rulePBWITHINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePBWITHINEx; /* Prevent compiler warnings */
    rulePBWITHINEx: ;

}
// $ANTLR end PBWITHIN

//   Comes from: 19:4: ( 'of' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OF
 *
 * Looks to match the characters the constitute the token OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOF(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OF;
       
    
    // Vmd.g:19:4: ( 'of' )
    // Vmd.g:19:6: 'of'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleOFEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOFEx; /* Prevent compiler warnings */
    ruleOFEx: ;

}
// $ANTLR end OF

//   Comes from: 20:6: ( 'same' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAME
 *
 * Looks to match the characters the constitute the token SAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAME(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SAME;
       
    
    // Vmd.g:20:6: ( 'same' )
    // Vmd.g:20:8: 'same'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleSAMEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSAMEEx; /* Prevent compiler warnings */
    ruleSAMEEx: ;

}
// $ANTLR end SAME

//   Comes from: 21:4: ( 'as' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AS
 *
 * Looks to match the characters the constitute the token AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAS(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AS;
       
    
    // Vmd.g:21:4: ( 'as' )
    // Vmd.g:21:6: 'as'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleASEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleASEx; /* Prevent compiler warnings */
    ruleASEx: ;

}
// $ANTLR end AS

//   Comes from: 22:5: ( 'not' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT
 *
 * Looks to match the characters the constitute the token NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT;
       
    
    // Vmd.g:22:5: ( 'not' )
    // Vmd.g:22:7: 'not'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleNOTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNOTEx; /* Prevent compiler warnings */
    ruleNOTEx: ;

}
// $ANTLR end NOT

//   Comes from: 23:4: ( 'to' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TO
 *
 * Looks to match the characters the constitute the token TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTO(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TO;
       
    
    // Vmd.g:23:4: ( 'to' )
    // Vmd.g:23:6: 'to'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleTOEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTOEx; /* Prevent compiler warnings */
    ruleTOEx: ;

}
// $ANTLR end TO

//   Comes from: 24:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__32
 *
 * Looks to match the characters the constitute the token T__32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__32(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__32;
       
    
    // Vmd.g:24:7: ( '(' )
    // Vmd.g:24:9: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__32Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__32Ex; /* Prevent compiler warnings */
    ruleT__32Ex: ;

}
// $ANTLR end T__32

//   Comes from: 25:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__33
 *
 * Looks to match the characters the constitute the token T__33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__33(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__33;
       
    
    // Vmd.g:25:7: ( ')' )
    // Vmd.g:25:9: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__33Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__33Ex; /* Prevent compiler warnings */
    ruleT__33Ex: ;

}
// $ANTLR end T__33

//   Comes from: 26:7: ( '\\\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__34
 *
 * Looks to match the characters the constitute the token T__34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__34(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__34;
       
    
    // Vmd.g:26:7: ( '\\\"' )
    // Vmd.g:26:9: '\\\"'
    {
        MATCHC('\"'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__34Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__34Ex; /* Prevent compiler warnings */
    ruleT__34Ex: ;

}
// $ANTLR end T__34

//   Comes from: 27:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__35
 *
 * Looks to match the characters the constitute the token T__35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__35(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__35;
       
    
    // Vmd.g:27:7: ( '+' )
    // Vmd.g:27:9: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__35Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__35Ex; /* Prevent compiler warnings */
    ruleT__35Ex: ;

}
// $ANTLR end T__35

//   Comes from: 28:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__36
 *
 * Looks to match the characters the constitute the token T__36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__36(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__36;
       
    
    // Vmd.g:28:7: ( '-' )
    // Vmd.g:28:9: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__36Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__36Ex; /* Prevent compiler warnings */
    ruleT__36Ex: ;

}
// $ANTLR end T__36

//   Comes from: 29:7: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__37
 *
 * Looks to match the characters the constitute the token T__37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__37(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__37;
       
    
    // Vmd.g:29:7: ( '*' )
    // Vmd.g:29:9: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__37Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__37Ex; /* Prevent compiler warnings */
    ruleT__37Ex: ;

}
// $ANTLR end T__37

//   Comes from: 30:7: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__38
 *
 * Looks to match the characters the constitute the token T__38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__38(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__38;
       
    
    // Vmd.g:30:7: ( '/' )
    // Vmd.g:30:9: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__38Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__38Ex; /* Prevent compiler warnings */
    ruleT__38Ex: ;

}
// $ANTLR end T__38

//   Comes from: 31:7: ( '**' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__39
 *
 * Looks to match the characters the constitute the token T__39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__39(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__39;
       
    
    // Vmd.g:31:7: ( '**' )
    // Vmd.g:31:9: '**'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleT__39Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__39Ex; /* Prevent compiler warnings */
    ruleT__39Ex: ;

}
// $ANTLR end T__39

//   Comes from: 32:7: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__40
 *
 * Looks to match the characters the constitute the token T__40
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__40(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__40;
       
    
    // Vmd.g:32:7: ( '^' )
    // Vmd.g:32:9: '^'
    {
        MATCHC('^'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__40Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__40Ex; /* Prevent compiler warnings */
    ruleT__40Ex: ;

}
// $ANTLR end T__40

//   Comes from: 168:3: ( ( ALPHA | DIGIT | '.' | '_' | '\\'' | '*' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIT
 *
 * Looks to match the characters the constitute the token LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLIT(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LIT;
       
    
    // Vmd.g:168:3: ( ( ALPHA | DIGIT | '.' | '_' | '\\'' | '*' )+ )
    // Vmd.g:168:5: ( ALPHA | DIGIT | '.' | '_' | '\\'' | '*' )+
    {
        // Vmd.g:168:5: ( ALPHA | DIGIT | '.' | '_' | '\\'' | '*' )+
        {
            int cnt1=0;

            for (;;)
            {
                int alt1=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA1_0 = LA(1);
        	    if ( (LA1_0 == '\'' || LA1_0 == '*' || LA1_0 == '.' || ((LA1_0 >= '0') && (LA1_0 <= '9')) || ((LA1_0 >= 'A') && (LA1_0 <= 'Z')) || LA1_0 == '_' || ((LA1_0 >= 'a') && (LA1_0 <= 'z'))) ) 
        	    {
        	        alt1=1;
        	    }

        	}
        	switch (alt1) 
        	{
        	    case 1:
        	        // Vmd.g:
        	        {
        	            if ( LA(1) == '\'' || LA(1) == '*' || LA(1) == '.' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleLITEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt1 >= 1 )
        		{
        		    goto loop1;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleLITEx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLITEx; /* Prevent compiler warnings */
    ruleLITEx: ;

}
// $ANTLR end LIT

//   Comes from: 171:16: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALPHA
 *
 * Looks to match the characters the constitute the token ALPHA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALPHA(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // Vmd.g:171:16: ( 'a' .. 'z' | 'A' .. 'Z' )
    // Vmd.g:
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleALPHAEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleALPHAEx; /* Prevent compiler warnings */
    ruleALPHAEx: ;

}
// $ANTLR end ALPHA

//   Comes from: 172:16: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // Vmd.g:172:16: ( '0' .. '9' )
    // Vmd.g:172:18: '0' .. '9'
    {
        MATCHRANGE('0', '9'); 
        if  (HASEXCEPTION())
        {
            goto ruleDIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 173:13: ( ( ' ' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pVmdLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;
       
    
    // Vmd.g:173:13: ( ( ' ' | '\\n' | '\\r' ) )
    // Vmd.g:173:15: ( ' ' | '\\n' | '\\r' )
    {
        if ( LA(1) == '\n' || LA(1) == '\r' || LA(1) == ' ' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSEx;
        }

        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pVmdLexer ctx)
{
    {
        //  Vmd.g:1:8: ( AND | OR | LESS | LESSEQ | MORE | MOREEQ | EQUAL | NEQUAL | WITHIN | WITHINBONDS | EXWITHIN | PBWITHIN | OF | SAME | AS | NOT | TO | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | T__40 | LIT | WS )
        
        ANTLR3_UINT32 alt2;

        alt2=28;

        alt2 = cdfa2.predict(ctx, RECOGNIZER, ISTREAM, &cdfa2);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt2) 
        {
    	case 1:
    	    // Vmd.g:1:10: AND
    	    {
    	        /* 1:10: AND */
    	        mAND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // Vmd.g:1:14: OR
    	    {
    	        /* 1:14: OR */
    	        mOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // Vmd.g:1:17: LESS
    	    {
    	        /* 1:17: LESS */
    	        mLESS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // Vmd.g:1:22: LESSEQ
    	    {
    	        /* 1:22: LESSEQ */
    	        mLESSEQ(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // Vmd.g:1:29: MORE
    	    {
    	        /* 1:29: MORE */
    	        mMORE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // Vmd.g:1:34: MOREEQ
    	    {
    	        /* 1:34: MOREEQ */
    	        mMOREEQ(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // Vmd.g:1:41: EQUAL
    	    {
    	        /* 1:41: EQUAL */
    	        mEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // Vmd.g:1:47: NEQUAL
    	    {
    	        /* 1:47: NEQUAL */
    	        mNEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // Vmd.g:1:54: WITHIN
    	    {
    	        /* 1:54: WITHIN */
    	        mWITHIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // Vmd.g:1:61: WITHINBONDS
    	    {
    	        /* 1:61: WITHINBONDS */
    	        mWITHINBONDS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // Vmd.g:1:73: EXWITHIN
    	    {
    	        /* 1:73: EXWITHIN */
    	        mEXWITHIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // Vmd.g:1:82: PBWITHIN
    	    {
    	        /* 1:82: PBWITHIN */
    	        mPBWITHIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // Vmd.g:1:91: OF
    	    {
    	        /* 1:91: OF */
    	        mOF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // Vmd.g:1:94: SAME
    	    {
    	        /* 1:94: SAME */
    	        mSAME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // Vmd.g:1:99: AS
    	    {
    	        /* 1:99: AS */
    	        mAS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // Vmd.g:1:102: NOT
    	    {
    	        /* 1:102: NOT */
    	        mNOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // Vmd.g:1:106: TO
    	    {
    	        /* 1:106: TO */
    	        mTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // Vmd.g:1:109: T__32
    	    {
    	        /* 1:109: T__32 */
    	        mT__32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // Vmd.g:1:115: T__33
    	    {
    	        /* 1:115: T__33 */
    	        mT__33(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // Vmd.g:1:121: T__34
    	    {
    	        /* 1:121: T__34 */
    	        mT__34(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // Vmd.g:1:127: T__35
    	    {
    	        /* 1:127: T__35 */
    	        mT__35(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // Vmd.g:1:133: T__36
    	    {
    	        /* 1:133: T__36 */
    	        mT__36(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // Vmd.g:1:139: T__37
    	    {
    	        /* 1:139: T__37 */
    	        mT__37(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // Vmd.g:1:145: T__38
    	    {
    	        /* 1:145: T__38 */
    	        mT__38(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // Vmd.g:1:151: T__39
    	    {
    	        /* 1:151: T__39 */
    	        mT__39(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // Vmd.g:1:157: T__40
    	    {
    	        /* 1:157: T__40 */
    	        mT__40(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // Vmd.g:1:163: LIT
    	    {
    	        /* 1:163: LIT */
    	        mLIT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // Vmd.g:1:167: WS
    	    {
    	        /* 1:167: WS */
    	        mWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
