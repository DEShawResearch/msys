#!/usr/bin/env desres-exec
#{
# desres-cleanenv \
# -m Python/2.5.1-09/bin \
# -- python $0 "$@"
#}

'''

dmsdump [ options ] input.dms
'''

import optparse
import subprocess
import sys

def read_terms(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'select name from %s order by name' % table],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    terms=p.communicate()[0].split()
    if p.returncode:
        return []
    return terms

# count the number of p0, p1, ... columns in the table
def get_columns(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'pragma table_info(%s)' % table],
            stdout=subprocess.PIPE)
    terms=p.communicate()[0].split('\n')
    atoms=[]
    params=[]
    for t in terms:
        elems=t.split('|')
        if len(elems) < 2: continue
        col = elems[1]
        if col and col[0]=='p':
            try:
                int(col[1:])
            except:
                pass
            else:
                atoms.append(col)
                continue
        params.append(col)

    return atoms, params

def has_table(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'select name from sqlite_master'],
        stdout=subprocess.PIPE)
    tables=p.communicate()[0].split('\n')
    return table in tables

def newline(out):
    #out.flush()
    #print >> out
    #out.flush()
    pass

def dump_terms(cmd, ipath, out, table, without_paraminfo, reorder ):
    terms = read_terms(ipath, table)
    terms.sort()
    for b in terms:
        atoms, params = get_columns(ipath, b)
        # don't print moiety for compatibility with ent output
        params = [p for p in params if p!='moiety']
        if without_paraminfo:
            exclude=set(('comment', 'ff', 'typekey'))
            params = [p for p in params if p not in exclude]

        if 'constrained' in params:
            params=[p for p in params if p!='constrained']
            params.sort()
            params.append('constrained')
        else:
            params.sort()

        p=['round(%s,6) as %s' % (x,x) for x in params]
        for i, x in enumerate(params):
            if x=='cmapid':
                p[i]=x

        a=','.join(atoms) 
        s=','.join(atoms+p)
        sql='select "%s", "%s", %s from %s' % (table, b, s, b)
        if reorder:
            s += ' order by %s' % a
        subprocess.call(cmd+[sql], stdout=out)
        newline(out)

def dmsdump(ipath, out, without_provenance = False, 
                        without_groups = False,
                        without_forcefield = False,
                        without_paraminfo = False,
                        reorder = False ):

    cmd='sqlite3 -header -column'.split()
    cmd.append(ipath)

    # global cell
    sql='select "global_cell", x,y,z from global_cell'
    subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # particles
    # we handle nonbonded specially so that permutations of the 
    # nbtype don't affect the result.
    atoms, params = get_columns(ipath, 'particle')
    skipped=set(('nbtype', 'nbtypeB', 'bfactor', 'occupancy', 'formal_charge', 'resonant_charge'))
    params=[p for p in params if p not in skipped]
    if without_groups:
        params = [p for p in params if not p.startswith('grp_')]

    s = ','.join(sorted(params))
    sql='select "particle", %s from particle' % s

    subprocess.call(cmd+[sql], stdout=out)
    newline(out)

    # bonds
    atoms, params = get_columns(ipath, 'bond')
    if('order' in params):
      subprocess.call(cmd+['select "bond", p0,p1, round("order") as "order" from bond order by p0, p1'], stdout=out)
    else:
      subprocess.call(cmd+['select "bond", p0,p1          from bond order by p0, p1'], stdout=out)
    newline(out)

    # bond, constraint, and virtual and drude terms
    dump_terms(cmd, ipath, out, 'bond_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'constraint_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'virtual_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'polar_term', without_paraminfo, reorder )

    # cmap, if present
    for c in (1,2,3,4,5,6):
        table="cmap%d" % c
        sql='select "%s", phi,psi,round(energy,6) as energy from %s' % (table,table)
        subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # nonbonded
    sql='select "nonbonded_info", vdw_funct, vdw_rule from nonbonded_info'
    subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    atoms, params = get_columns(ipath, 'nonbonded_param')
    for p in ('id', 'ff', 'typekey', 'comment'): 
        if p in params:
            params.remove(p)
    params.sort()
    s = ','.join(['round(nb.%s,6) as %s' % (p,p) for p in params])
    sql='select "nonbonded", p.id, %s from particle as p join nonbonded_param as nb on p.nbtype = nb.id' % s
    subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # exclusions
    sql='select "exclusion", * from exclusion'
    if reorder:
        sql += ' order by p0,p1'
    subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # alchemical_particle
    if has_table(ipath, 'alchemical_particle'):
        s = ','.join(
                ['round(nbA.%s,6) as %sA, round(nbB.%s,6) as %sB' % (p,p,p,p) 
                    for p in params])
        sql='''
        select "alchemical_particle", p.p0 as p0, moiety, chargeA, chargeB, %s
        from alchemical_particle as p 
        join nonbonded_param as nbA on p.nbtypeA = nbA.id
        join nonbonded_param as nbB on p.nbtypeB = nbB.id
        ''' % s
        p=subprocess.Popen(cmd+[sql], stdout=out, stderr=subprocess.PIPE)
        print >> sys.stderr, p.communicate()[1]


    # viparr_info, forcefield
    for blk in ('provenance', 'viparr_info', 'forcefield'):
        if blk=='provenance' and without_provenance: continue
        if blk=='forcefield' and without_forcefield: continue
        if has_table(ipath, blk):
            atoms, params = get_columns(ipath, blk)
            params.sort()
            sql='select "%s", %s from %s' % (blk, ','.join(params), blk)
            subprocess.call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)


if __name__=="__main__":
    parser = optparse.OptionParser( usage=__doc__)
    parser.add_option('--without-provenance', help="don't write provenance",
            action="store_true", default=False)
    parser.add_option('--without-groups', help="don't write grp_xxx columns",
            action="store_true", default=False)
    parser.add_option('--without-forcefield', help="don't write forcefield info",
            action="store_true", default=False)
    parser.add_option('--without-paraminfo', help="don't write comment, typekey, ff in terms",
            action="store_true", default=False)
    parser.add_option('--reorder', default=False, action="store_true", 
            help='order ouput of terms by particle id')

    opts, args = parser.parse_args()
    if len(args) != 1:
        parser.error("Incorrect number of arguments")

    dmsdump( args[0], sys.stdout, **opts.__dict__)


# vim: filetype=python
# @COPYRIGHT@

