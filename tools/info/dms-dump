#!/usr/bin/env desres-exec
# -*- python -*-
#{
# source `dirname $0`/../share/MODULES && \
# exec garden with -c -m $PYTHON/bin \
# -- python $0 "$@"
#}

'''

dmsdump [ options ] input.dms

dms-dump generates a textual representation of a dms file that can be
understood by humans and compared to the output of another dms file.
A certain amount of canonicalization is applied to the contents of the dms
file in order to make this happen:

 * all floating point values are rounded to six decimals;

 * all force terms are sorted by particle id, i.e. p0, p1, ...

 * all columns are sorted alphabetically;

 * rather than printing the nbtype of each particle, the nonbonded parameters
   of each particle are dumped with a "nonbonded" label at the start of
   each line.
'''

import optparse
import subprocess
import sys

def read_terms(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'select name from %s order by name' % table],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    terms=p.communicate()[0].split()
    if p.returncode:
        return []
    return terms

# count the number of p0, p1, ... columns in the table
def get_columns(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'pragma table_info(%s)' % table],
            stdout=subprocess.PIPE)
    terms=p.communicate()[0].split('\n')
    atoms=[]
    params=[]
    for t in terms:
        elems=t.split('|')
        if len(elems) < 2: continue
        col = elems[1]
        if col and col[0]=='p':
            try:
                int(col[1:])
            except:
                pass
            else:
                atoms.append(col)
                continue
        params.append(col)

    return atoms, params

def has_table(ipath, table):
    p=subprocess.Popen(['sqlite3', ipath, 'select name from sqlite_master'],
        stdout=subprocess.PIPE)
    tables=p.communicate()[0].split('\n')
    return table in tables

def newline(out):
    #out.flush()
    #print >> out
    #out.flush()
    pass

def dump_terms(cmd, ipath, out, table, without_paraminfo, reorder ):
    terms = read_terms(ipath, table)
    terms.sort()
    for b in terms:
        atoms, params = get_columns(ipath, b)
        # don't print moiety for compatibility with ent output
        params = [p for p in params if p!='moiety']
        if without_paraminfo:
            exclude=set((
                    'memo', 'comment', 'ff', 'type', 'typekey',
                    'memoA', 'commentA', 'ffA', 'typeA', 'typekeyA',
                    'memoB', 'commentB', 'ffB', 'typeB', 'typekeyB',
                    ))
            params = [p for p in params if p not in exclude]

        if 'constrained' in params:
            params=[p for p in params if p!='constrained']
            params.sort()
            params.append('constrained')
        else:
            params.sort()

        a=','.join(atoms) 
        s=','.join(atoms+params)
        sql='select "%s", "%s", %s from %s' % (table, b, s, b)
        if reorder:
            sql += ' order by %s' % a
        subprocess.check_call(cmd+[sql], stdout=out)
        newline(out)

def dmsdump(ipath, out, without_provenance = False, 
                        without_groups = False,
                        without_forcefield = False,
                        without_paraminfo = False,
                        without_pos = False,
                        reorder = False ):

    cmd='sqlite3 -header'.split()
    cmd.append(ipath)

    # global cell
    sql='select "global_cell", x,y,z from global_cell'
    subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # particles
    # we handle nonbonded specially so that permutations of the 
    # nbtype don't affect the result.
    atoms, params = get_columns(ipath, 'particle')
    skipped=set(('nbtype', 'nbtypeB', 'bfactor', 'occupancy', 'formal_charge', 'resonant_charge'))
    params=[p for p in params if p not in skipped]
    if without_groups:
        params = [p for p in params if not p.startswith('grp_')]
    if without_pos:
        params = [p for p in params if p not in ['x','y','z','vx','vy','vz']]
    if 'segid' not in params:
        params.append('segid')
        fake_segid=True
    else:
        fake_segid=False
    if 'name' not in params:
        params.append('name')
        fake_name=True
    else:
        fake_name=False
    if 'resname' not in params:
        params.append('resname')
        fake_resname=True
    else:
        fake_resname=False
    params.sort()
    if fake_segid:
        params[params.index('segid')]='"" as segid'
    if fake_name:
        params[params.index('name')]='"" as name'
    else:
        params[params.index('name')]='trim(name) as name'
    if fake_resname:
        params[params.index('resname')]='"" as resname'
    else:
        params[params.index('resname')]='trim(resname) as resname'

    s = ','.join(params)

    sql='select "particle", %s from particle' % s

    subprocess.check_call(cmd+[sql], stdout=out)
    newline(out)

    # bonds
    atoms, params = get_columns(ipath, 'bond')
    if('order' in params):
      subprocess.check_call(cmd+['select "bond", p0,p1, "order" from bond order by p0, p1'], stdout=out)
    else:
      subprocess.check_call(cmd+['select "bond", p0,p1, 1.0 as "order" from bond order by p0, p1'], stdout=out)
    newline(out)

    # bond, constraint, and virtual and drude terms
    dump_terms(cmd, ipath, out, 'bond_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'constraint_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'virtual_term', without_paraminfo, reorder )
    dump_terms(cmd, ipath, out, 'polar_term', without_paraminfo, reorder )

    # cmap, if present
    for c in range(1,100):
        table="cmap%d" % c
        if not has_table(ipath,table): continue
        sql='select "%s", phi,psi,energy from %s' % (table,table)
        subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # nonbonded
    if(has_table(ipath,"nonbonded_info")):
       sql='select "nonbonded_info", vdw_funct, vdw_rule from nonbonded_info'
       subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    if(has_table(ipath,'nonbonded_param')):
        atoms, params = get_columns(ipath, 'nonbonded_param')
        if without_paraminfo:
            for p in ( 'ff', 'type', 'typekey', 'memo', 'comment', 'override',
                       'ffA', 'typeA', 'typekeyA', 'memoA', 'commentA', 'overrideA',
                       'ffB', 'typeB', 'typekeyB', 'memoB', 'commentB', 'overrideB',
                          ):
                if p in params:
                    params.remove(p)
        params.remove('id')
        params.sort()
 
        s=''
        if not without_paraminfo:
            s = 'nb.id as param, '
        s += ','.join(['nb.%s as %s' % (p,p) for p in params])
        sql='select "nonbonded", p.id, %s from particle as p join nonbonded_param as nb on p.nbtype = nb.id' % s
        subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # nonbonded combined
    if has_table(ipath, "nonbonded_combined_param"):
        atoms, params = get_columns(ipath, "nonbonded_combined_param")
        params.remove("param1")
        params.remove("param2")
        params.sort()
        params=['"nonbonded_combined"', "param1", "param2"] + params
        s=",".join(params)
        sql='select %s from nonbonded_combined_param' % s
        subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # exclusions
    if(has_table(ipath, 'exclusion')):
        sql='select "exclusion", * from exclusion'
        if reorder:
            sql += ' order by p0,p1'
        subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)

    # alchemical_particle
    if has_table(ipath, 'alchemical_particle'):
        s = ','.join(
                ['nbA.%s as %sA, nbB.%s as %sB' % (p,p,p,p) 
                    for p in params])
        sql='''
        select "alchemical_particle", p.p0 as p0, chargeA, chargeB, %s
        from alchemical_particle as p 
        join nonbonded_param as nbA on p.nbtypeA = nbA.id
        join nonbonded_param as nbB on p.nbtypeB = nbB.id
        ''' % s
        p=subprocess.Popen(cmd+[sql], stdout=out, stderr=subprocess.PIPE)
        print >> sys.stderr, p.communicate()[1]


    # viparr_info, forcefield
    for blk in ('provenance', 'viparr_info', 'forcefield'):
        if blk=='provenance' and without_provenance: continue
        if blk=='forcefield' and without_forcefield: continue
        if has_table(ipath, blk):
            atoms, params = get_columns(ipath, blk)
            params.sort()
            sql='select "%s", %s from %s' % (blk, ','.join(params), blk)
            subprocess.check_call(cmd+[sql], stdout=out, stderr=subprocess.PIPE)


if __name__=="__main__":
    parser = optparse.OptionParser( usage=__doc__)
    parser.add_option('--without-provenance', help="don't write provenance",
            action="store_true", default=False)
    parser.add_option('--without-groups', help="don't write grp_xxx columns",
            action="store_true", default=False)
    parser.add_option('--without-forcefield', help="don't write forcefield info",
            action="store_true", default=False)
    parser.add_option('--without-paraminfo', help="don't write memo, type, ff, comment, or typekey in terms",
            action="store_true", default=False)
    parser.add_option('--without-pos', help="don't write pos and vel",
            action="store_true", default=False)
    parser.add_option('--reorder', default=False, action="store_true", 
            help='order ouput of terms by particle id')

    opts, args = parser.parse_args()
    if len(args) != 1:
        parser.error("Incorrect number of arguments")

    dmsdump( args[0], sys.stdout, **opts.__dict__)


# vim: filetype=python
# @COPYRIGHT@

